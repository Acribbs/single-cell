---
title: "Sample QC"
output: html_document
---

This page sets out the quality control analysis for the single cells. It will be used to remove "Bad" cells before progressing for downstream analysis.

```{r setup, include=FALSE}
#source('functions.R')
library(scran)
library(ggplot2)
library(RColorBrewer)
library(scater)
library(SummarizedExperiment)
library(ComplexHeatmap)
library(ggrepel)
library(tidyverse)
library(SingleCellExperiment)
library(limma)
library(pheatmap)
options(stringsAsFactors = FALSE)
library(yaml)

opts <- read_yaml("../../../pipeline.yml")
species <- opts$sce$species
mito_mad <- as.logical(opts$qc$mito_median_absolute_deviation)
spike_ins <- as.logical(opts$qc$spike_ins)
transcript_thresh <- opts$qc$min_transcripts

if(mito_mad){
mad <- mito_mad
} else{
mad <- 0
mito_thresh <- opts$qc$max_mito
}
```

# Load RDS data

```{r}
sce <- readRDS("sce.rds")

```{r, include = FALSE}
rowData(sce)$ensembl_gene_id <- rownames(sce)
if(species == "human"){
  symbol <- "hgnc_symbol"
  ensembl_data <- "hsapiens_gene_ensembl"
}
if(species == "mouse"){
  symbol <- "mgi_symbol"
  ensembl_data <- "mmusculus_gene_ensembl"
}

sce <- scater::getBMFeatureAnnos(sce, filters = "ensembl_gene_id", attributes = c("ensembl_gene_id", symbol, "chromosome_name"), dataset = ensembl_data, host = "uswest.ensembl.org")

# Use mitochondrial and ribosomal DNA as feature controls
mt_genes <- which(rowData(sce)$chromosome_name == "MT")
ribo_genes <- grepl("^RP[LS]", rowData(sce)[[symbol]])

feature_ctrls <- list(mito = rownames(sce)[mt_genes], ribo = rownames(sce)[ribo_genes])

lapply(feature_ctrls, head)

# Calculate metrics
sce <- calculateQCMetrics(sce, feature_controls = feature_ctrls)

colnames(colData(sce))
```

```{r outliers, include=FALSE}
# Initiate a dataframe that will allow saving of the outliers.
outlier <- data.frame(row.names = colnames(sce))
```

#### Need to run multiqc on the data and then use that to import the metrics for quality will skip and move to using scater


# **Scater**

# Examining the most highly expressed genes

We look at a plot that shows the top 50 (by default) most-expressed features. Each row in the plot below corresponds to a gene, and each bar corresponds to the expression of a gene in a single cell. The circle indicates the median expression of each gene, with which genes are sorted.


```{r HighestExprs, echo=FALSE}
plotHighestExprs(sce, exprs_values = "counts", feature_names_to_plot = symbol)
```

# Library size

Next we consider the total number of reads per sample. Wells with few reads/molecules are likely to have been broken or failed to capture a cell, and should thus be removed.

```{r, echo=FALSE}
hist(
    sce$total_counts,
    breaks = 100
)
abline(v = 100, col = "red")

filter_by_total_counts.outliers <- (sce$total_counts < 100)
table(filter_by_total_counts.outliers)
outlier$total_counts <- (sce$total_counts < 100)


total_cells <- length(colnames(sce)) 
total_umis <- sum(counts(sce))
umi_per_cell_average <- total_umis/total_cells
distinct_umis_per_cell_average <- sum(sce$total_features_by_counts)/total_cells
```

# Detected genes

In addition to ensuring sufficient sequencing depth for each sample, we also want to make sure that the reads are distributed across the transcriptome. Thus, we count the total number of unique genes detected in each sample.

```{r, echo=FALSE, warning=FALSE}
hist(
    as.numeric(sce$log10_total_features_by_counts),
    breaks = 100
)
abline(v = 2, col = "red")

filter_by_detected_genes.outliers <- (sce$log10_total_features_by_counts < 2)
outlier$detected_genes <- (sce$log10_total_features_by_counts < 2)
```

# Frequency of expression as a function of the mean
The frequency of expression (i.e. number of cells with non-zero expression) against the mean. These two metrics should be positively correlated with each other for most genes.
```{r, echo=FALSE}
plotExprsFreqVsMean(sce)
```

# Percentage of counts assigned to feature controls
Well-behaved cells should have a large number of expressed features and and a low percentage of expression from feature controls. High percentage expression from feature controls and few expressed features are indicative of blank and failed cells.
```{r, echo = FALSE}
plotColData(sce, x = "total_features_by_counts",
    y = "pct_counts_feature_control") +
    theme(legend.position = "top") +
    stat_smooth(method = "lm", se = FALSE, size = 2, fullrange = TRUE)
```

# Mitochondrial gene content

Mitochondrial percentage threshold
```{r, include = FALSE}
metric <- sce$pct_counts_mito
if(mad){
# Using median absolute deviations
scater.MT.M <- median(metric)
scater.MT.MAD <- mad(metric)
mt_threshold <- scater.MT.M + 2 * scater.MT.MAD
mt_lower_threshold <- scater.MT.M - 2 * scater.MT.MAD
scater.MT.outliers <- metric > mt_threshold | metric < mt_lower_threshold
table(scater.MT.outliers)
outlier$MT <- metric > scater.MT.M + 2 * scater.MT.MAD
} else{
# Mitochondrial threshold usually 10%, change parameter in yml file or directly here
# Total counts threshold larger than
mt_threshold <- mito_thresh
}
scater.MT.outliers <- metric > mt_threshold
table(scater.MT.outliers)
outlier$MT <- metric > mt_threshold
```

Have a look at spread of cells with high % mito  
High mitochondrial genes indicate improper lysing of the single cells and are indicitive of poor RNA capture.
```{r, echo = FALSE}

plotColData(sce, x = "total_features_by_counts", y = "pct_counts_mito") + geom_hline(yintercept = mt_threshold, col ="red") + geom_vline(xintercept = transcript_thresh, col = "red")
```

## PCA plot coloured by percent of mitochondrial dna
```{r, echo = FALSE}
plotPCA(sce, colour_by = "pct_counts_mito")
```

```{r mt_plot_QC,  echo=FALSE}
if(mad){
ggplot(as.data.frame(colData(sce)), aes(rownames(colData(sce)), pct_counts_mito)) +
  geom_point() +
  geom_hline(
    yintercept = scater.MT.M + 2 * c(-1,1) * scater.MT.MAD,
    colour = "red", linetype = 2:1
  ) +
  geom_hline(yintercept = scater.MT.M) +
  theme(
    axis.ticks.x = element_blank(), axis.text.x = element_blank(),
    legend.position = "bottom", legend.box = "vertical"
  )
}
```

```{r, echo=FALSE}
plotExprsFreqVsMean(sce)

```

# Library complexity {#Library_complexity .tabset .tabset-fade}

Library complexity refers to the proportion of assigned reads accounted for by the N most abundant features within each individual sample, with values for N usually ranging from tens to hundreds. It is expected to observe a lower library complexity in single cells relative to bulk samples, due to higher dropout events in single cells, and the union of multiple phenotypes within bulk samples. In contrast, blank samples are expected to have extremely low library complexity, as only 92 ERCC spike-ins sequences are expected in those libraries, in contrast to thousands of genomic features in biological samples.

## Full

```{r full_lib, echo=FALSE}
# Need to parameterise the generation of these plots
plotScater(sce, nfeatures = 300, exprs_values = "counts")
```

# scater calulate QC metrics

## Calulate single-cell QC

```{r single_QC, include=FALSE}

# parameterise with if statement

ERCCs <- grep("^ERCC-[[:digit:]]+$", rownames(counts), value = TRUE)
sce.sc <- calculateQCMetrics(
  sce,
  feature_controls = list(ERCC = ERCCs)
)
```

```{r full_QC,  include=FALSE}
sceset <- calculateQCMetrics(
  sce
  )
```


# MT gene content

High mitochronrial genes indicate improper lysing of the single cells and are indicitive of poor RNA capture.

```{r}
metric <- sceset$pct_counts_MT
scater.MT.M <- median(metric)
scater.MT.MAD <- mad(metric)
scater.MT.outliers <- metric > scater.MT.M + 2 * scater.MT.MAD
table(scater.MT.outliers)
outlier$MT <- metric > scater.MT.M + 2 * scater.MT.MAD
```

```{r mt_plot_QC,  echo=FALSE}
ggplot(as.data.frame(colData(sceset)), aes(rownames(colData(sceset)), pct_counts_MT)) +
  geom_point() +
  geom_hline(
    yintercept = scater.MT.M + 2 * c(-1,1) * scater.MT.MAD,
    colour = "red", linetype = 2:1
  ) +
  geom_hline(yintercept = scater.MT.M) +
  theme(
    axis.ticks.x = element_blank(), axis.text.x = element_blank(),
    legend.position = "bottom", legend.box = "vertical"
  )
```


## Top proportion of library assigned to most abundant features {.tabset}

### Top 50

```{r Top50,  echo=FALSE}
metric <- sceset$pct_counts_top_50_features
scater.top50.M <- median(metric)
scater.top50.MAD <- mad(metric)
scater.top50.outliers <-
  metric > scater.top50.M + 4 * scater.top50.MAD
table(scater.top50.outliers)
outlier$Top50 <- metric > scater.top50.M + 4 * scater.top50.MAD

```

```{r Top50_plot,  echo=FALSE}
ggplot(as.data.frame(colData(sceset)), aes(rownames(colData(sceset)), pct_counts_top_50_features)) +
  geom_point() +
  geom_hline(
    yintercept = scater.top50.M + 4 * c(-1,1) * scater.top50.MAD,
    colour = "red", linetype = 2:1
  ) +
  geom_hline(yintercept = scater.top50.M) +
  theme(
    axis.ticks.x = element_blank(), axis.text.x = element_blank(),
    legend.position = "bottom", legend.box = "vertical"
  )
```


### Top 100

```{r Top100,  echo=FALSE}
metric <- sceset$pct_counts_top_100_features
scater.top100.M <- median(metric)
scater.top100.MAD <- mad(metric)
scater.top100.outliers <-
  metric > scater.top100.M + 3 * scater.top100.MAD
table(scater.top100.outliers)
outlier$Top100 <- metric > scater.top100.M + 4 * scater.top100.MAD

```


```{r Top100_plot, echo=FALSE}
ggplot(as.data.frame(colData(sceset)), aes(rownames(colData(sceset)), pct_counts_top_100_features)) +
  geom_point() +
  geom_hline(
    yintercept = scater.top100.M + 3 * c(-1,1) * scater.top100.MAD,
    colour = "red", linetype = 2:1
  ) +
  geom_hline(yintercept = scater.top100.M) +
  theme(
    axis.ticks.x = element_blank(), axis.text.x = element_blank(),
    legend.position = "bottom", legend.box = "vertical"
  )
```

### Top 200

```{r Top200,  echo=FALSE}
metric <- sceset$pct_counts_top_200_features
scater.top200.M <- median(metric)
scater.top200.MAD <- mad(metric)
scater.top200.outliers <-
  metric > scater.top200.M + 3 * scater.top200.MAD
table(scater.top200.outliers)
outlier$Top200 <- metric > scater.top100.M + 4 * scater.top100.MAD
```

```{r Top200_plot,  echo=FALSE}
ggplot(as.data.frame(colData(sceset)), aes(rownames(colData(sceset)), pct_counts_top_200_features)) +
  geom_point() +
  geom_hline(
    yintercept = scater.top200.M + 3 * c(-1,1) * scater.top200.MAD,
    colour = "red", linetype = 2:1
  ) +
  geom_hline(yintercept = scater.top200.M) +
  theme(
    axis.ticks.x = element_blank(), axis.text.x = element_blank(),
    legend.position = "bottom", legend.box = "vertical"
  )

```

# Global summary of QC metrics

```{r, include=FALSE}
outlier.vars <- ls(pattern = "outliers$")
outliers.df <- data.frame(lapply(
  outlier.vars,
  function(x){ifelse(get(x), "Fail", "Pass")}
))
colnames(outliers.df) <- gsub(".outliers$", "", outlier.vars)
rownames(outliers.df) <- colnames(sce.sc)
```

## Cells passing

```{r sum_failed, echo=FALSE }
colSums(outliers.df == "Pass")

```

## Cells failing

```{r, echo=FALSE}
colSums(outliers.df == "Fail")
```

## Summary of failures 

This displays the counts for the number of failures for each fature

```{r count_sc, echo=FALSE}
table(rowSums(outliers.df == "Fail"))
```

## Summary of pass and fails

```{r idx_pass, echo=FALSE}
idx.pass <- rowSums(outliers.df == "Fail") == 0
table(idx.pass)
```

## Heatmap of pass and fails

```{r heatmap_fail, cache=FALSE, echo=FALSE}
col9 <- brewer.pal(10, "Set3")[c(1:8, 10)]

sample.order.supervised <- order(sceset)

hm <- Heatmap(
  as.matrix(outliers.df),
  name = "Filter",
  col = c("Pass" = "lightblue", "Fail" = "red"),
  cluster_rows = FALSE, show_row_names = FALSE
)

postscript("cells_passing_filter.eps")
draw(hm)
dev.off()
draw(hm)
```


# Remove cells that fail QC

```{r pass, cache=FALSE, echo=FALSE}
sce.pass <- sceset[,idx.pass]
assay(sce.pass, "log2_counts") <- log2(counts(sceset[,idx.pass]) + 1)
length(colnames(sce.pass))
```


```{r, include = FALSE}
# Recompute size factors, normalisation etc
sce.pass <- scran::computeSumFactors(sce.pass, BPPARAM = MulticoreParam(10))

sce.pass <- normalize(sce.pass)

sce.pass <- calculateQCMetrics(sce.pass)
plotColData(sce.pass, x = "total_features_by_counts", y = "pct_counts_mito")+  geom_hline(yintercept =10, col ="red") + geom_vline(xintercept = 1000, col = "red")
# All data points within thresholds, sanity check
# Can rerun plots with sce.pass
```


```{r}
saveRDS(sce.pass, file="pass.rds")
```

```{r log_file, include = FALSE}

species_log <- paste(c("species", species), collapse = "\t")
spike_ins_log <- paste(c("spike_ins", spike_ins), collapse = "\t")
spike_ins <- as.logical(opts$qc$spike_ins)
transcript_thresh_log <- paste(c("transcript_min_threshold", transcript_thresh), collapse = "\t")
if(mad){
  mito_thresh <- "NA"
}else{
  mt_lower_threshold <- "NA"
  mt_threshold <- "NA"
}

mito_thresh_log <- paste(c("mitochondrial_percentage_hard_upper_threshold", mito_thresh), collapse = "\t")  
mito_mad_thresh_low_log <- paste(c("mitochondrial_percentage_mad_lower_threshold", mt_lower_threshold), collapse = "\t") 
mito_mad_thresh_high_log <- paste(c("mitochondrial_percentage_mad_upper_threshold", mt_threshold), collapse = "\t") 
total_cell_log <- paste(c("total_cells_in", total_cells), collapse = "\t") 
total_umis_log <- paste(c("total_UMIs", total_umis), collapse = "\t") 
cells_passing <- sum(idx.pass)
cells_failing <- total_cells - cells_passing
total_cell_pass_log <- paste(c("total_cells_passing_qc", cells_passing), collapse = "\t") 
total_cell_fail_log <- paste(c("total_cells_failing_qc", cells_failing), collapse = "\t") 


cells_failing_detected_genes <- sum(outliers.df$filter_by_detected_genes == "Fail")
cells_failing_detected_genes_log <- paste(c("cells_failing_number_detected_genes", cells_failing_detected_genes), collapse = "\t")
cells_failing_filter_by_total_counts <- sum(outliers.df$filter_by_total_counts == "Fail")
cells_failing_filter_by_total_counts_log <- paste(c("cells_failing_total_counts", cells_failing_filter_by_total_counts), collapse = "\t")
cells_failing_MT <- sum(outliers.df$scater.MT == "Fail")
cells_failing_MT_log <- paste(c("cells_failing_MT", cells_failing_MT), collapse = "\t")
cells_failing_top50 <- sum(outliers.df$scater.top50 == "Fail")
cells_failing_top50_log <- paste(c("cells_failing_top50", cells_failing_top50), collapse = "\t")
cells_failing_top100 <- sum(outliers.df$scater.top100 == "Fail")
cells_failing_top100_log <- paste(c("cells_failing_top100", cells_failing_top100), collapse = "\t")
cells_failing_top200 <- sum(outliers.df$scater.top200 == "Fail")
cells_failing_top200_log <- paste(c("cells_failing_top200", cells_failing_top200), collapse = "\t")



labs <-  c("species", "spike_ins", "transcript_min_threshold", "mitochondrial_percentage_hard_upper_threshold", "mitochondrial_percentage_mad_lower_threshold", "mitochondrial_percentage_mad_upper_threshold", "total_cells_in", "total_UMIs", "total_cells_passing_qc", "total_cells_failing_qc", "cells_failing_number_detected_genes", "cells_failing_total_counts", "cells_failing_MT_percent", "cells_failing_top50", "cells_failing_top100", "cells_failing_top200")
tib <- tibble(labels = labs)
tib$values <- c(species, spike_ins, transcript_thresh, mito_thresh, mt_lower_threshold, mt_threshold, total_cells, total_umis, cells_passing, cells_failing, cells_failing_detected_genes, cells_failing_filter_by_total_counts, cells_failing_MT, cells_failing_top50, cells_failing_top100,cells_failing_top200 )

write_tsv(tib, "./run_qc_log.txt", col_names = FALSE)

```

